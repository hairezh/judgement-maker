<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>osu!mania Judgement PNG Maker (0/50/100/200/300/300g)</title>
  <style>
    :root{
      --bg:#0b0c0f; --fg:#e8e8e8; --muted:#9aa0a6;
      --panel:rgba(255,255,255,.04); --border:rgba(255,255,255,.10);
      --accent:#7c5cff; --r:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:radial-gradient(1200px 700px at 70% 10%, rgba(124,92,255,.20), transparent 60%),
                 radial-gradient(900px 600px at 10% 10%, rgba(0,212,255,.12), transparent 60%),
                 var(--bg);
      color:var(--fg);
    }
    header{
      padding:18px 18px 10px;
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.20);
      backdrop-filter: blur(8px);
      position:sticky; top:0; z-index:5;
    }
    header h1{margin:0; font-size:16px; letter-spacing:.2px}
    header .hint{color:var(--muted); font-size:12px}
    .wrap{
      padding:18px;
      display:grid;
      grid-template-columns: 410px 1fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns: 1fr; }
    }

    .card{
      border:1px solid var(--border);
      background:var(--panel);
      border-radius:var(--r);
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card .title{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card .title strong{font-size:13px}
    .card .content{padding:12px}

    .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .row3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px}

    .field{display:flex; flex-direction:column; gap:6px; margin-bottom:10px}
    label{font-size:12px; color:var(--muted)}
    input[type="text"], input[type="number"], select, textarea{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--fg);
      outline:none;
    }
    textarea{min-height:84px; resize:vertical; font-family:var(--mono); font-size:12px}
    input[type="color"]{
      width:100%;
      height:40px;
      border-radius:12px;
      border:1px solid var(--border);
      background:transparent;
      padding:4px;
    }
    input[type="file"]{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px dashed var(--border);
      background:rgba(0,0,0,.18);
      color:var(--muted);
    }

    .btns{display:flex; flex-wrap:wrap; gap:10px}
    button{
      border:1px solid var(--border);
      background:rgba(124,92,255,.18);
      color:var(--fg);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
      font-size:12px;
    }
    button:hover{background:rgba(124,92,255,.28)}
    button.secondary{background:rgba(255,255,255,.06)}
    button.secondary:hover{background:rgba(255,255,255,.10)}
    button.danger{background:rgba(255,80,80,.15)}
    button.danger:hover{background:rgba(255,80,80,.22)}
    .small{font-size:12px; color:var(--muted); line-height:1.4}
    .pill{
      font-family:var(--mono);
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.22);
      color:var(--muted);
    }

    .tabs{
      display:flex; flex-wrap:wrap; gap:8px;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.14);
    }
    .tab{
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      padding:8px 10px;
      border-radius:999px;
      font-family:var(--mono);
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{
      background:rgba(124,92,255,.30);
      border-color:rgba(124,92,255,.55);
      color:var(--fg);
    }

    .stage{
      display:flex; flex-direction:column; gap:12px;
      padding:12px;
    }
    .canvasWrap{
      border-radius:18px;
      border:1px solid var(--border);
      background:
        linear-gradient(45deg, rgba(255,255,255,.06) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.06) 75%, rgba(255,255,255,.06)),
        linear-gradient(45deg, rgba(255,255,255,.06) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.06) 75%, rgba(255,255,255,.06));
      background-position: 0 0, 14px 14px;
      background-size: 28px 28px;
      overflow:hidden;
      position:relative;
    }
    canvas{display:block; width:100%; height:auto; image-rendering:auto;}

    .stageTop{
      display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }
    .stageTop .left{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    .stageTop .right{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--border);
      padding:6px 8px;
      border-radius:10px;
      background:rgba(0,0,0,.20);
    }
    .divider{height:1px; background:var(--border); margin:10px 0}
    .toast{
      position:fixed;
      right:14px;
      bottom:14px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.55);
      color:var(--fg);
      font-size:12px;
      opacity:0;
      transform:translateY(8px);
      transition:.2s;
      pointer-events:none;
    }
    .toast.show{opacity:1; transform:translateY(0)}
  </style>
</head>
<body>
  <header>
    <h1>osu!mania Judgement PNG Maker</h1>
    <span class="hint">Edite cada judgement (0/50/100/200/300/300g) e exporte 6 PNGs nomeados.</span>
  </header>

  <div class="wrap">
    <!-- LEFT -->
    <section class="card">
      <div class="title">
        <strong>Config</strong>
        <span class="pill" id="statusPill">pronto</span>
      </div>

      <div class="tabs" id="tabs"></div>

      <div class="content">
        <div class="field">
          <label>Texto do judgement (s√≥ deste selecionado)</label>
          <input id="txt" type="text" value="300" />
        </div>

        <div class="row">
          <div class="field">
            <label>Fonte (nome)</label>
            <input id="fontName" type="text" value="Arial Black" />
          </div>
          <div class="field">
            <label>Upload de fonte (.ttf/.otf)</label>
            <input id="fontFile" type="file" accept=".ttf,.otf" />
          </div>
        </div>

        <div class="row3">
          <div class="field">
            <label>Tamanho (px)</label>
            <input id="fontSize" type="number" value="92" min="1" step="1" />
          </div>
          <div class="field">
            <label>Tracking</label>
            <input id="tracking" type="number" value="0" step="0.5" />
          </div>
          <div class="field">
            <label>Inclina√ß√£o (¬∞)</label>
            <input id="skewDeg" type="number" value="0" step="0.5" />
          </div>
        </div>

        <div class="row3">
          <div class="field">
            <label>Cor do texto</label>
            <input id="fill" type="color" value="#ffffff" />
          </div>
          <div class="field">
            <label>Outline (px)</label>
            <input id="strokeW" type="number" value="10" min="0" step="1" />
          </div>
          <div class="field">
            <label>Cor do outline</label>
            <input id="stroke" type="color" value="#000000" />
          </div>
        </div>

        <div class="row3">
          <div class="field">
            <label>Sombra (blur)</label>
            <input id="shadowBlur" type="number" value="0" min="0" step="1" />
          </div>
          <div class="field">
            <label>Sombra X</label>
            <input id="shadowX" type="number" value="0" step="1" />
          </div>
          <div class="field">
            <label>Sombra Y</label>
            <input id="shadowY" type="number" value="0" step="1" />
          </div>
        </div>

        <div class="row3">
          <div class="field">
            <label>Cor da sombra</label>
            <input id="shadowColor" type="color" value="#000000" />
          </div>
          <div class="field">
            <label>Glow (blur)</label>
            <input id="glowBlur" type="number" value="18" min="0" step="1" />
          </div>
          <div class="field">
            <label>Cor do glow</label>
            <input id="glowColor" type="color" value="#7c5cff" />
          </div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <div class="field">
            <label>Tamanho do PNG</label>
            <select id="sizePreset">
              <option value="512x256" selected>512 √ó 256 (comum)</option>
              <option value="256x256">256 √ó 256</option>
              <option value="512x512">512 √ó 512</option>
              <option value="1024x512">1024 √ó 512</option>
              <option value="1024x1024">1024 √ó 1024</option>
              <option value="custom">Custom‚Ä¶</option>
            </select>
          </div>
          <div class="field">
            <label>Resolu√ß√£o interna (scale)</label>
            <select id="scale">
              <option value="1">1x</option>
              <option value="2" selected>2x (n√≠tido)</option>
              <option value="3">3x</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="field">
            <label>Largura custom</label>
            <input id="cw" type="number" value="512" min="1" step="1" />
          </div>
          <div class="field">
            <label>Altura custom</label>
            <input id="ch" type="number" value="256" min="1" step="1" />
          </div>
        </div>

        <div class="row3">
          <div class="field">
            <label>Offset X (este judgement)</label>
            <input id="offX" type="number" value="0" step="1" />
          </div>
          <div class="field">
            <label>Offset Y (este judgement)</label>
            <input id="offY" type="number" value="0" step="1" />
          </div>
          <div class="field">
            <label>Alpha (este judgement)</label>
            <input id="alpha" type="number" value="1" min="0" max="1" step="0.05" />
          </div>
        </div>

        <div class="divider"></div>

        <div class="field">
          <label>√çcone / s√≠mbolo (PNG opcional ‚Äî s√≥ deste judgement)</label>
          <input id="iconFile" type="file" accept="image/png,image/webp,image/jpeg" />
        </div>

        <div class="row3">
          <div class="field">
            <label>√çcone escala</label>
            <input id="iconScale" type="number" value="1" min="0" step="0.05" />
          </div>
          <div class="field">
            <label>√çcone offset X</label>
            <input id="iconX" type="number" value="0" step="1" />
          </div>
          <div class="field">
            <label>√çcone offset Y</label>
            <input id="iconY" type="number" value="0" step="1" />
          </div>
        </div>

        <div class="row3">
          <div class="field">
            <label>√çcone atr√°s do texto?</label>
            <select id="iconBehind">
              <option value="yes" selected>Sim</option>
              <option value="no">N√£o</option>
            </select>
          </div>
          <div class="field">
            <label>Suavizar √≠cone</label>
            <select id="iconSmooth">
              <option value="yes" selected>Sim</option>
              <option value="no">N√£o (pixelado)</option>
            </select>
          </div>
          <div class="field">
            <label>Remover √≠cone</label>
            <button class="danger" id="clearIcon" type="button">Limpar</button>
          </div>
        </div>

        <div class="divider"></div>

        <div class="btns">
          <button id="downloadOne" type="button">Baixar PNG (selecionado)</button>
          <button id="exportAll" type="button">Exportar 6 PNGs</button>
          <button id="reset" class="secondary" type="button">Reset</button>
        </div>

        <p class="small">
          Dica: selecione o judgement no topo, ajuste texto/offset/√≠cone dele, e no fim clique <b>Exportar 6 PNGs</b>.
        </p>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="card">
      <div class="title">
        <strong>Preview</strong>
        <div class="right">
          <span class="kbd">Arraste = move offset</span>
          <span class="kbd">Shift+arraste = move √≠cone</span>
        </div>
      </div>

      <div class="stage">
        <div class="stageTop">
          <div class="left">
            <span class="pill" id="dimPill">512√ó256</span>
            <span class="pill" id="fontPill">fonte: Arial Black</span>
            <span class="pill" id="whichPill">editando: 300</span>
          </div>
          <div class="right">
            <button id="toggleGuides" class="secondary" type="button">Guias: ON</button>
            <button id="toggleBG" class="secondary" type="button">Fundo preview</button>
          </div>
        </div>

        <div class="canvasWrap" id="canvasWrap">
          <canvas id="c"></canvas>
        </div>

        <p class="small">
          Export sai com <b>fundo transparente</b>. Xadrez √© s√≥ preview.
        </p>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ========= helpers =========
    const $ = (id) => document.getElementById(id);
    const toast = (msg) => {
      const t = $("toast");
      t.textContent = msg;
      t.classList.add("show");
      clearTimeout(toast._tm);
      toast._tm = setTimeout(()=>t.classList.remove("show"), 1600);
    };
    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const sanitizeName = (s)=> (s||"judgement").toString().trim()
      .replace(/[\\/:*?"<>|]+/g,"").replace(/\s+/g,"_").slice(0,80) || "judgement";

    // ========= Global style (shared) =========
    const shared = {
      fontName: "Arial Black",
      fontSize: 92,
      tracking: 0,
      skewDeg: 0,

      fill: "#ffffff",
      strokeW: 10,
      stroke: "#000000",

      shadowBlur: 0,
      shadowX: 0,
      shadowY: 0,
      shadowColor: "#000000",

      glowBlur: 18,
      glowColor: "#7c5cff",

      w: 512,
      h: 256,
      scale: 2,

      guides: true,
      previewBG: false
    };

    // ========= Per-judgement data =========
    const keys = ["0","50","100","200","300","300g"];
    const per = {};
    for(const k of keys){
      per[k] = {
        text: k,
        alpha: 1,
        offX: 0,
        offY: 0,
        iconImg: null,
        iconScale: 1,
        iconX: 0,
        iconY: 0,
        iconBehind: true,
        iconSmooth: true
      };
    }
    let active = "300";

    // ========= Canvas =========
    const canvas = $("c");
    const ctx = canvas.getContext("2d");

    function setCanvasSize(){
      canvas.width  = Math.max(1, Math.floor(shared.w * shared.scale));
      canvas.height = Math.max(1, Math.floor(shared.h * shared.scale));
      $("dimPill").textContent = `${shared.w}√ó${shared.h}`;
    }

    function measureTextBox(text, font){
      ctx.save();
      ctx.font = font;
      const m = ctx.measureText(text);
      const ascent  = (m.actualBoundingBoxAscent ?? m.fontBoundingBoxAscent ?? (shared.fontSize * 0.8));
      const descent = (m.actualBoundingBoxDescent ?? m.fontBoundingBoxDescent ?? (shared.fontSize * 0.2));
      const left  = (m.actualBoundingBoxLeft ?? 0);
      const right = (m.actualBoundingBoxRight ?? m.width);
      ctx.restore();
      return { ascent, descent, left, right, width: right+left, height: ascent+descent };
    }

    function clear(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(shared.previewBG){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }

    function drawGuides(){
      if(!shared.guides) return;
      const W = canvas.width, H = canvas.height;
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.lineWidth = Math.max(1, shared.scale);
      ctx.beginPath();
      ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H);
      ctx.moveTo(0, H/2); ctx.lineTo(W, H/2);
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.stroke();
      const pad = 14 * shared.scale;
      ctx.strokeStyle = "rgba(124,92,255,.35)";
      ctx.strokeRect(pad, pad, W - pad*2, H - pad*2);
      ctx.restore();
    }

    function drawTextWithTracking(text, x, y, tracking, strokeOnly, fillOnly){
      if(!text) return;
      if(!tracking){
        if(strokeOnly) ctx.strokeText(text, x, y);
        if(fillOnly) ctx.fillText(text, x, y);
        return;
      }
      const chars = [...text];
      const widths = chars.map(ch => ctx.measureText(ch).width);
      const total = widths.reduce((a,b)=>a+b,0) + tracking*(chars.length-1);
      let startX = x - total/2;
      for(let i=0;i<chars.length;i++){
        const cx = startX + widths[i]/2;
        if(strokeOnly) ctx.strokeText(chars[i], cx, y);
        if(fillOnly) ctx.fillText(chars[i], cx, y);
        startX += widths[i] + tracking;
      }
    }

    function drawIcon(centerX, centerY, jd){
      if(!jd.iconImg) return;
      const img = jd.iconImg;
      const scale = jd.iconScale * shared.scale;
      const iw = img.naturalWidth * scale;
      const ih = img.naturalHeight * scale;
      const x = centerX - iw/2 + (jd.iconX * shared.scale);
      const y = centerY - ih/2 + (jd.iconY * shared.scale);

      ctx.save();
      ctx.imageSmoothingEnabled = !!jd.iconSmooth;
      ctx.globalAlpha = clamp(jd.alpha,0,1);
      ctx.drawImage(img, x, y, iw, ih);
      ctx.restore();
    }

    function drawJudgement(jKey){
      const jd = per[jKey];
      const size = shared.fontSize * shared.scale;
      const font = `${size}px "${shared.fontName}"`;
      const text = jd.text ?? "";
      const tracking = Number(shared.tracking || 0) * shared.scale;

      // Center pivot + per-judgement offsets
      const centerX = canvas.width/2  + (jd.offX * shared.scale);
      const centerY = canvas.height/2 + (jd.offY * shared.scale);

      // Real centering
      const box = measureTextBox(text, font);
      const baselineToMiddle = (box.ascent - box.descent) / 2;
      const x0 = centerX;
      const y0 = centerY + baselineToMiddle;

      // Icon behind?
      if(jd.iconBehind) drawIcon(centerX, centerY, jd);

      ctx.save();
      ctx.globalAlpha = clamp(jd.alpha,0,1);
      ctx.font = font;
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      // skew
      const skew = Math.tan((Number(shared.skewDeg)||0) * Math.PI/180);
      ctx.transform(1, 0, skew, 1, 0, 0);

      // glow
      if(Number(shared.glowBlur) > 0){
        ctx.save();
        ctx.shadowBlur = Number(shared.glowBlur) * shared.scale;
        ctx.shadowColor = shared.glowColor;
        ctx.fillStyle = shared.fill;
        drawTextWithTracking(text, x0, y0, tracking, false, true);
        ctx.restore();
      }

      // shadow
      if(Number(shared.shadowBlur) > 0 || Number(shared.shadowX) !== 0 || Number(shared.shadowY) !== 0){
        ctx.save();
        ctx.shadowBlur = Number(shared.shadowBlur) * shared.scale;
        ctx.shadowColor = shared.shadowColor;
        ctx.shadowOffsetX = Number(shared.shadowX) * shared.scale;
        ctx.shadowOffsetY = Number(shared.shadowY) * shared.scale;
        ctx.fillStyle = shared.fill;
        drawTextWithTracking(text, x0, y0, tracking, false, true);
        ctx.restore();
      }

      // outline
      if(Number(shared.strokeW) > 0){
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.lineWidth = Number(shared.strokeW) * shared.scale;
        ctx.strokeStyle = shared.stroke;
        drawTextWithTracking(text, x0, y0, tracking, true, false);
      }

      // fill
      ctx.fillStyle = shared.fill;
      drawTextWithTracking(text, x0, y0, tracking, false, true);

      ctx.restore();

      // Icon front?
      if(!jd.iconBehind) drawIcon(centerX, centerY, jd);
    }

    function render(){
      setCanvasSize();
      clear();
      drawJudgement(active);
      drawGuides();
      $("fontPill").textContent = `fonte: ${shared.fontName}`;
      $("whichPill").textContent = `editando: ${active}`;
    }

    function getPNGBlob(){
      return new Promise((resolve) => canvas.toBlob(b=>resolve(b), "image/png"));
    }
    function downloadBlob(blob, filename){
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{
        URL.revokeObjectURL(a.href);
        a.remove();
      }, 200);
    }

    // ========= Tabs =========
    function buildTabs(){
      const root = $("tabs");
      root.innerHTML = "";
      for(const k of keys){
        const b = document.createElement("div");
        b.className = "tab" + (k===active ? " active" : "");
        b.textContent = k;
        b.addEventListener("click", ()=>{
          active = k;
          syncUIFromActive();
          buildTabs();
          render();
        });
        root.appendChild(b);
      }
    }

    // ========= UI sync =========
    function syncUIFromActive(){
      const jd = per[active];
      $("txt").value = jd.text;
      $("offX").value = jd.offX;
      $("offY").value = jd.offY;
      $("alpha").value = jd.alpha;
      $("iconScale").value = jd.iconScale;
      $("iconX").value = jd.iconX;
      $("iconY").value = jd.iconY;
      $("iconBehind").value = jd.iconBehind ? "yes" : "no";
      $("iconSmooth").value = jd.iconSmooth ? "yes" : "no";
      $("iconFile").value = "";
    }

    function syncSharedUI(){
      $("fontName").value = shared.fontName;
      $("fontSize").value = shared.fontSize;
      $("tracking").value = shared.tracking;
      $("skewDeg").value = shared.skewDeg;
      $("fill").value = shared.fill;
      $("strokeW").value = shared.strokeW;
      $("stroke").value = shared.stroke;
      $("shadowBlur").value = shared.shadowBlur;
      $("shadowX").value = shared.shadowX;
      $("shadowY").value = shared.shadowY;
      $("shadowColor").value = shared.shadowColor;
      $("glowBlur").value = shared.glowBlur;
      $("glowColor").value = shared.glowColor;
      $("cw").value = shared.w;
      $("ch").value = shared.h;
      $("scale").value = String(shared.scale);
      $("sizePreset").value = "512x256";
      $("toggleGuides").textContent = `Guias: ${shared.guides ? "ON" : "OFF"}`;
    }

    // ========= Bind shared inputs =========
    const bindShared = (id, key, parser=(v)=>v)=>{
      const el = $(id);
      const read = ()=>{
        shared[key] = parser(el.value);
        render();
      };
      el.addEventListener("input", read);
      el.addEventListener("change", read);
    };

    bindShared("fontName","fontName",v=>v);
    bindShared("fontSize","fontSize",v=>Number(v||0));
    bindShared("tracking","tracking",v=>Number(v||0));
    bindShared("skewDeg","skewDeg",v=>Number(v||0));
    bindShared("fill","fill",v=>v);
    bindShared("strokeW","strokeW",v=>Number(v||0));
    bindShared("stroke","stroke",v=>v);
    bindShared("shadowBlur","shadowBlur",v=>Number(v||0));
    bindShared("shadowX","shadowX",v=>Number(v||0));
    bindShared("shadowY","shadowY",v=>Number(v||0));
    bindShared("shadowColor","shadowColor",v=>v);
    bindShared("glowBlur","glowBlur",v=>Number(v||0));
    bindShared("glowColor","glowColor",v=>v);

    // ========= Bind per-judgement inputs =========
    const bindPer = (id, setter)=>{
      const el = $(id);
      const read = ()=>{
        setter(el.value);
        render();
      };
      el.addEventListener("input", read);
      el.addEventListener("change", read);
    };

    bindPer("txt", v=> per[active].text = v);
    bindPer("offX", v=> per[active].offX = Number(v||0));
    bindPer("offY", v=> per[active].offY = Number(v||0));
    bindPer("alpha", v=> per[active].alpha = Number(v||1));

    bindPer("iconScale", v=> per[active].iconScale = Number(v||1));
    bindPer("iconX", v=> per[active].iconX = Number(v||0));
    bindPer("iconY", v=> per[active].iconY = Number(v||0));

    $("iconBehind").addEventListener("change", (e)=>{
      per[active].iconBehind = e.target.value === "yes";
      render();
    });
    $("iconSmooth").addEventListener("change", (e)=>{
      per[active].iconSmooth = e.target.value === "yes";
      render();
    });

    // ========= size preset =========
    function applySizePreset(){
      const v = $("sizePreset").value;
      if(v !== "custom"){
        const [w,h] = v.split("x").map(Number);
        shared.w = w; shared.h = h;
        $("cw").value = w;
        $("ch").value = h;
      }else{
        shared.w = Number($("cw").value||512);
        shared.h = Number($("ch").value||256);
      }
      render();
    }
    $("sizePreset").addEventListener("change", applySizePreset);
    $("cw").addEventListener("change", ()=>{
      $("sizePreset").value = "custom";
      shared.w = Number($("cw").value||512);
      render();
    });
    $("ch").addEventListener("change", ()=>{
      $("sizePreset").value = "custom";
      shared.h = Number($("ch").value||256);
      render();
    });
    $("scale").addEventListener("change", (e)=>{
      shared.scale = Number(e.target.value||1);
      render();
    });

    // ========= Font upload =========
    $("fontFile").addEventListener("change", async (e)=>{
      const file = e.target.files?.[0];
      if(!file) return;
      try{
        const buf = await file.arrayBuffer();
        const fname = file.name.replace(/\.(ttf|otf)$/i,"");
        const face = new FontFace(fname, buf);
        $("statusPill").textContent = "carregando fonte‚Ä¶";
        await face.load();
        document.fonts.add(face);
        shared.fontName = fname;
        $("fontName").value = fname;
        $("statusPill").textContent = "fonte ok";
        toast("Fonte carregada ‚úÖ");
        await document.fonts.ready;
        render();
      }catch(err){
        console.error(err);
        $("statusPill").textContent = "erro fonte";
        toast("Falha ao carregar fonte üòµ");
      }
    });

    // ========= Icon upload (per active) =========
    $("iconFile").addEventListener("change", async (e)=>{
      const file = e.target.files?.[0];
      if(!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = ()=>{
        per[active].iconImg = img;
        URL.revokeObjectURL(url);
        toast(`√çcone carregado (${active}) ‚úÖ`);
        render();
      };
      img.onerror = ()=>{
        URL.revokeObjectURL(url);
        toast("Falha ao carregar √≠cone üòµ");
      };
      img.src = url;
    });

    $("clearIcon").addEventListener("click", ()=>{
      per[active].iconImg = null;
      $("iconFile").value = "";
      toast(`√çcone removido (${active})`);
      render();
    });

    // ========= Buttons =========
    $("downloadOne").addEventListener("click", async ()=>{
      render();
      const blob = await getPNGBlob();
      downloadBlob(blob, `${sanitizeName(active)}.png`);
      toast(`Baixando ${active}.png‚Ä¶`);
    });

    $("exportAll").addEventListener("click", async ()=>{
      const old = active;
      for(const k of keys){
        active = k;
        buildTabs();
        syncUIFromActive();
        render();
        const blob = await getPNGBlob();
        downloadBlob(blob, `${sanitizeName(k)}.png`);
        await sleep(140);
      }
      active = old;
      buildTabs();
      syncUIFromActive();
      render();
      toast("Exportou 6 PNGs ‚úÖ");
    });

    $("reset").addEventListener("click", ()=>{
      Object.assign(shared, {
        fontName:"Arial Black", fontSize:92, tracking:0, skewDeg:0,
        fill:"#ffffff", strokeW:10, stroke:"#000000",
        shadowBlur:0, shadowX:0, shadowY:0, shadowColor:"#000000",
        glowBlur:18, glowColor:"#7c5cff",
        w:512, h:256, scale:2,
        guides:true, previewBG:false
      });
      for(const k of keys){
        per[k] = {
          text: k, alpha:1, offX:0, offY:0,
          iconImg:null, iconScale:1, iconX:0, iconY:0,
          iconBehind:true, iconSmooth:true
        };
      }
      active = "300";
      buildTabs();
      syncSharedUI();
      syncUIFromActive();
      $("statusPill").textContent = "reset";
      toast("Reset feito");
      render();
    });

    $("toggleGuides").addEventListener("click", ()=>{
      shared.guides = !shared.guides;
      $("toggleGuides").textContent = `Guias: ${shared.guides ? "ON" : "OFF"}`;
      render();
    });

    $("toggleBG").addEventListener("click", ()=>{
      shared.previewBG = !shared.previewBG;
      render();
      toast(`Fundo preview: ${shared.previewBG ? "ON" : "OFF"}`);
    });

    // ========= Dragging offsets =========
    let dragging = false;
    let dragMode = "text";
    let lastX=0, lastY=0;

    $("canvasWrap").addEventListener("mousedown", (e)=>{
      dragging = true;
      dragMode = e.shiftKey ? "icon" : "text";
      lastX = e.clientX;
      lastY = e.clientY;
      e.preventDefault();
    });
    window.addEventListener("mouseup", ()=>dragging=false);
    window.addEventListener("mousemove", (e)=>{
      if(!dragging) return;

      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      const rect = canvas.getBoundingClientRect();
      const sx = shared.w / rect.width;
      const sy = shared.h / rect.height;

      const jd = per[active];
      if(dragMode === "icon"){
        jd.iconX += dx * sx;
        jd.iconY += dy * sy;
        $("iconX").value = Math.round(jd.iconX);
        $("iconY").value = Math.round(jd.iconY);
      }else{
        jd.offX += dx * sx;
        jd.offY += dy * sy;
        $("offX").value = Math.round(jd.offX);
        $("offY").value = Math.round(jd.offY);
      }
      render();
    });

    // ========= init =========
    (async function init(){
      buildTabs();
      syncSharedUI();
      syncUIFromActive();
      await document.fonts.ready;
      render();
      toast("Pronto ‚úÖ");
    })();
  </script>
</body>
</html>
