<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>osu!mania judgement-maker</title>
  <style>
    :root{
      --bg:#0b0c0f; --fg:#e8e8e8; --muted:#9aa0a6;
      --panel:rgba(255,255,255,.04); --border:rgba(255,255,255,.10);
      --accent:#7c5cff; --r:14px; --r2:10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:radial-gradient(1200px 700px at 70% 10%, rgba(124,92,255,.20), transparent 60%),
                 radial-gradient(900px 600px at 10% 10%, rgba(0,212,255,.12), transparent 60%),
                 var(--bg);
      color:var(--fg);
    }
    header{
      padding:18px 18px 10px;
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.20);
      backdrop-filter: blur(8px);
      position:sticky; top:0; z-index:5;
    }
    header h1{margin:0; font-size:16px; letter-spacing:.2px}
    header .hint{color:var(--muted); font-size:12px}

    .wrap{
      padding:18px;
      display:grid;
      grid-template-columns: 480px 1fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns: 1fr;}
    }

    .card{
      border:1px solid var(--border);
      background:var(--panel);
      border-radius:var(--r);
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card .title{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card .title strong{font-size:13px}
    .card .content{padding:12px}

    .tabs{
      display:flex; flex-wrap:wrap; gap:8px;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.14);
    }
    .tab{
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      padding:8px 10px;
      border-radius: var(--r2);
      font-family:var(--mono);
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{
      background:rgba(124,92,255,.30);
      border-color:rgba(124,92,255,.55);
      color:var(--fg);
    }

    .field{display:flex; flex-direction:column; gap:6px; margin-bottom:10px}
    label{font-size:12px; color:var(--muted)}
    input[type="text"], select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--fg);
      outline:none;
    }
    input[type="color"]{
      width:100%;
      height:40px;
      border-radius:12px;
      border:1px solid var(--border);
      background:transparent;
      padding:4px;
    }

    .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .row3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px}

    .btns{display:flex; flex-wrap:wrap; gap:10px}
    button{
      border:1px solid var(--border);
      background:rgba(124,92,255,.18);
      color:var(--fg);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
      font-size:12px;
    }
    button:hover{background:rgba(124,92,255,.28)}
    button.secondary{background:rgba(255,255,255,.06)}
    button.secondary:hover{background:rgba(255,255,255,.10)}

    .pill{
      font-family:var(--mono);
      font-size:11px;
      padding:4px 8px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.22);
      color:var(--muted);
    }
    .divider{height:1px; background:var(--border); margin:10px 0}
    .small{font-size:12px; color:var(--muted); line-height:1.4}

    .stage{display:flex; flex-direction:column; gap:12px; padding:12px;}
    .stageTop{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .stageTop .left{display:flex; align-items:center; gap:10px; flex-wrap:wrap}

    .canvasWrap{
      border-radius:18px;
      border:1px solid var(--border);
      background:
        linear-gradient(45deg, rgba(255,255,255,.06) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.06) 75%, rgba(255,255,255,.06)),
        linear-gradient(45deg, rgba(255,255,255,.06) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.06) 75%, rgba(255,255,255,.06));
      background-position: 0 0, 14px 14px;
      background-size: 28px 28px;
      overflow:hidden;
      position:relative;
      padding:18px;
    }
    canvas{
      display:block;
      width:100%;
      max-width: 980px;
      height:auto;
      margin:0 auto;
      border-radius:14px;
      background:transparent;
      image-rendering:auto;
    }

    /* sliders com valor editável */
    .sliderRow{
      display:flex; align-items:center; gap:10px;
      padding:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.22);
      border-radius:12px;
    }
    .sliderRow input[type="range"]{width:100%}
    .num{
      width:90px;
      font-family:var(--mono);
      font-size:12px;
      padding:8px 8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--fg);
      outline:none;
      text-align:right;
    }
    .suffix{
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted);
      min-width:28px;
      text-align:left;
    }

    .toast{
      position:fixed; right:14px; bottom:14px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.55);
      color:var(--fg);
      font-size:12px;
      opacity:0;
      transform:translateY(8px);
      transition:.2s;
      pointer-events:none;
    }
    .toast.show{opacity:1; transform:translateY(0)}
  </style>
</head>
<body>
<header>
  <h1>judgement-maker</h1>
  <span class="hint">
    Export fixo: 288×56 e 576×112 (@2x). Master sempre @2x. Tudo centralizado. Configs por hit.
  </span>
</header>

<div class="wrap">
  <section class="card">
    <div class="title">
      <strong>Config</strong>
      <span class="pill" id="statusPill">pronto</span>
    </div>

    <div class="tabs" id="tabs"></div>

    <div class="content">
      <div class="field">
        <label>Texto (só deste hit)</label>
        <input id="txt" type="text" value="300" />
      </div>

      <div class="row">
        <div class="field">
          <label>Fonte (local)</label>
          <select id="fontSelect"></select>
        </div>
        <div class="field">
          <label>Fundo preview</label>
          <button id="toggleBG" class="secondary" type="button">Alternar</button>
        </div>
      </div>

      <p class="small">
        Fontes locais: coloque arquivos em <b>./fonts/</b> e edite a lista <b>FONT_LIBRARY</b> no script.
      </p>

      <div class="divider"></div>

      <!-- sliders por hit -->
      <div class="field">
        <label>Tamanho da fonte</label>
        <div class="sliderRow">
          <input id="s_fontSize" type="range" min="0" max="100" value="55" />
          <input id="n_fontSize" class="num" type="number" step="1" />
          <div class="suffix">px</div>
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label>Tracking</label>
          <div class="sliderRow">
            <input id="s_tracking" type="range" min="0" max="100" value="50" />
            <input id="n_tracking" class="num" type="number" step="0.1" />
            <div class="suffix">px</div>
          </div>
        </div>
        <div class="field">
          <label>Inclinação</label>
          <div class="sliderRow">
            <input id="s_skew" type="range" min="0" max="100" value="50" />
            <input id="n_skew" class="num" type="number" step="0.1" />
            <div class="suffix">°</div>
          </div>
        </div>
      </div>

      <div class="row3">
        <div class="field">
          <label>Cor do texto</label>
          <input id="fill" type="color" value="#ffffff" />
        </div>
        <div class="field">
          <label>Outline</label>
          <div class="sliderRow">
            <input id="s_strokeW" type="range" min="0" max="100" value="35" />
            <input id="n_strokeW" class="num" type="number" step="0.1" />
            <div class="suffix">px</div>
          </div>
        </div>
        <div class="field">
          <label>Cor do outline</label>
          <input id="stroke" type="color" value="#000000" />
        </div>
      </div>

      <div class="row3">
        <div class="field">
          <label>Sombra blur</label>
          <div class="sliderRow">
            <input id="s_shadowBlur" type="range" min="0" max="100" value="0" />
            <input id="n_shadowBlur" class="num" type="number" step="0.1" />
            <div class="suffix">px</div>
          </div>
        </div>
        <div class="field">
          <label>Sombra X</label>
          <div class="sliderRow">
            <input id="s_shadowX" type="range" min="0" max="100" value="50" />
            <input id="n_shadowX" class="num" type="number" step="0.1" />
            <div class="suffix">px</div>
          </div>
        </div>
        <div class="field">
          <label>Sombra Y</label>
          <div class="sliderRow">
            <input id="s_shadowY" type="range" min="0" max="100" value="50" />
            <input id="n_shadowY" class="num" type="number" step="0.1" />
            <div class="suffix">px</div>
          </div>
        </div>
      </div>

      <div class="row3">
        <div class="field">
          <label>Cor da sombra</label>
          <input id="shadowColor" type="color" value="#000000" />
        </div>
        <div class="field">
          <label>Glow blur</label>
          <div class="sliderRow">
            <input id="s_glowBlur" type="range" min="0" max="100" value="35" />
            <input id="n_glowBlur" class="num" type="number" step="0.1" />
            <div class="suffix">px</div>
          </div>
        </div>
        <div class="field">
          <label>Cor do glow</label>
          <input id="glowColor" type="color" value="#7c5cff" />
        </div>
      </div>

      <div class="divider"></div>

      <div class="btns">
        <button id="downloadOne" type="button">Baixar (selecionado + @2x)</button>
        <button id="exportAll" type="button">Exportar 12 PNGs</button>
        <button id="reset" class="secondary" type="button">Reset</button>
      </div>

      <p class="small">
        Tudo é por-hit agora (inclusive cores). Texto sempre centralizado.
      </p>
    </div>
  </section>

  <section class="card">
    <div class="title">
      <strong>Preview</strong>
      <span class="pill" id="whichPill">editando: 300</span>
    </div>

    <div class="stage">
      <div class="stageTop">
        <div class="left">
          <span class="pill">576×112 (preview)</span>
          <span class="pill" id="fontPill">fonte: —</span>
        </div>
      </div>

      <div class="canvasWrap">
        <canvas id="c"></canvas>
      </div>

      <p class="small">Export sai com fundo transparente. Xadrez é só preview.</p>
    </div>
  </section>
</div>

<div class="toast" id="toast"></div>

<script>
  // ==========================================================
  // 1) FONTES LOCAIS
  // Coloque seus arquivos em: ./fonts/
  // Depois edite a lista abaixo com os nomes exatos dos arquivos.
  //
  // Exemplo:
  // { name: "Torus", file: "Torus-Regular.ttf" }
  // { name: "Varela Round", file: "VarelaRound-Regular.ttf" }
  // ==========================================================
  const FONT_LIBRARY = [
    { name: "Arial (fallback)", file: null }, // fallback do sistema
    // { name: "MinhaFonte", file: "MinhaFonte.ttf" },
  ];

  // helpers
  const $ = (id)=>document.getElementById(id);
  const toast = (msg)=>{
    const t=$("toast");
    t.textContent=msg; t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm=setTimeout(()=>t.classList.remove("show"),1600);
  };
  const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
  const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
  const sanitizeName=(s)=> (s||"judgement").toString().trim()
    .replace(/[\\/:*?"<>|]+/g,"").replace(/\s+/g,"_").slice(0,80) || "judgement";

  // sizes fixos
  const BASE_W = 288, BASE_H = 56;
  const MASTER_SCALE = 2;
  const MASTER_W = BASE_W * MASTER_SCALE;
  const MASTER_H = BASE_H * MASTER_SCALE;

  // hits
  const keys = ["0","50","100","200","300","300g"];
  let active = "300";

  // ==========================================================
  // 2) PARAMETROS POR HIT (TUDO INDIVIDUAL)
  // ==========================================================
  function makeDefaultsForHit(label){
    return {
      text: label,

      fontKey: 0,         // índice no FONT_LIBRARY
      fontSize: 34,       // px (base 288x56)
      tracking: 0,        // px
      skewDeg: 0,         // graus

      fill: "#ffffff",
      strokeW: 4,
      stroke: "#000000",

      shadowBlur: 0,
      shadowX: 0,
      shadowY: 0,
      shadowColor: "#000000",

      glowBlur: 10,
      glowColor: "#7c5cff"
    };
  }

  const per = {};
  for(const k of keys) per[k] = makeDefaultsForHit(k);

  // preview global
  const shared = { previewBG:false };

  // ==========================================================
  // 3) SLIDERS 0..100 + VALOR EDITÁVEL (COM MAPEAMENTO)
  // ==========================================================
  // range linear: slider s(0..100) <-> value v(min..max)
  function sToV(s, min, max){ return min + (s/100)*(max-min); }
  function vToS(v, min, max){
    if(max === min) return 0;
    return ((v - min) / (max - min)) * 100;
  }

  // limites internos (pra digitar e pra slider)
  const R = {
    fontSize:   { min: 18,  max: 70,  step: 1   },
    tracking:   { min: -8,  max: 8,   step: 0.1 },
    skewDeg:    { min: -14, max: 14,  step: 0.1 },
    strokeW:    { min: 0,   max: 10,  step: 0.1 },
    glowBlur:   { min: 0,   max: 22,  step: 0.1 },
    shadowBlur: { min: 0,   max: 18,  step: 0.1 },
    shadowX:    { min: -10, max: 10,  step: 0.1 },
    shadowY:    { min: -10, max: 10,  step: 0.1 },
  };

  function setFromSlider(prop, s){
    const hit = per[active];
    const rr = R[prop];
    hit[prop] = sToV(Number(s), rr.min, rr.max);
  }
  function setFromNumber(prop, v){
    const hit = per[active];
    const rr = R[prop];
    hit[prop] = clamp(Number(v), rr.min, rr.max);
  }

  function syncControl(prop, sId, nId){
    const hit = per[active];
    const rr = R[prop];
    const sEl = $(sId);
    const nEl = $(nId);

    // set steps for manual input
    nEl.step = rr.step;

    // write from state -> controls
    const v = hit[prop];
    sEl.value = String(clamp(vToS(v, rr.min, rr.max), 0, 100));
    nEl.value = (rr.step >= 1 ? String(Math.round(v)) : String(Number(v).toFixed(1)));
  }

  function bindRangePair(prop, sId, nId){
    const sEl = $(sId);
    const nEl = $(nId);

    const onSlider = ()=>{
      setFromSlider(prop, sEl.value);
      syncAllForActive(); // mantém coerente
      renderPreview();
    };
    const onNumber = ()=>{
      setFromNumber(prop, nEl.value);
      syncAllForActive();
      renderPreview();
    };

    sEl.addEventListener("input", onSlider);
    sEl.addEventListener("change", onSlider);
    nEl.addEventListener("input", onNumber);
    nEl.addEventListener("change", onNumber);
  }

  // ==========================================================
  // 4) CANVAS + PIPELINE DE QUALIDADE (MASK -> OUTLINE -> GLOW/SHADOW -> FILL)
  // ==========================================================
  const canvas = $("c");
  const ctx = canvas.getContext("2d");

  const maskC = document.createElement("canvas");
  const maskX = maskC.getContext("2d");

  const workC = document.createElement("canvas");
  const workX = workC.getContext("2d");

  const masterC = document.createElement("canvas");
  const masterX = masterC.getContext("2d");

  const downC = document.createElement("canvas");
  const downX = downC.getContext("2d");

  function setSize(cnv, w, h){ cnv.width=w; cnv.height=h; }

  function clearCtx(x, w, h){
    x.clearRect(0,0,w,h);
    if(shared.previewBG){
      x.save();
      x.fillStyle="rgba(0,0,0,.35)";
      x.fillRect(0,0,w,h);
      x.restore();
    }
  }

  function setupTextCtx(x, hit, scale){
    x.font = `${hit.fontSize*scale}px "${getFontName(hit.fontKey)}"`;
    x.textAlign = "center";
    x.textBaseline = "alphabetic";
  }

  function renderTextMask(x, W, H, scale, hit){
    clearCtx(x, W, H);

    x.save();
    setupTextCtx(x, hit, scale);
    x.fillStyle = "#ffffff";

    const text = hit.text ?? "";
    const m = x.measureText(text);
    const ascent  = (m.actualBoundingBoxAscent ?? m.fontBoundingBoxAscent ?? (hit.fontSize*0.8));
    const descent = (m.actualBoundingBoxDescent ?? m.fontBoundingBoxDescent ?? (hit.fontSize*0.2));
    const baselineToMiddle = (ascent - descent)/2;

    // centralização travada + snapping
    const cx = Math.round(W/2);
    const y0 = Math.round(H/2 + baselineToMiddle);

    const tracking = hit.tracking * scale;

    // skew via transform (mantém centro)
    const skew = Math.tan((hit.skewDeg || 0) * Math.PI/180);
    x.transform(1, 0, skew, 1, 0, 0);

    if(!tracking){
      x.fillText(text, cx, y0);
    }else{
      const chars=[...text];
      const widths=chars.map(ch=>x.measureText(ch).width);
      const total=widths.reduce((a,b)=>a+b,0)+tracking*(chars.length-1);
      let startX = cx - total/2;
      for(let i=0;i<chars.length;i++){
        const px = startX + widths[i]/2;
        x.fillText(chars[i], px, y0);
        startX += widths[i] + tracking;
      }
    }

    x.restore();
  }

  function expandMaskTo(x, W, H, radiusPx){
    x.save();
    x.globalCompositeOperation = "source-over";
    x.imageSmoothingEnabled = true;

    const r = Math.max(0, Math.round(radiusPx));
    if(r === 0){
      x.drawImage(maskC, 0,0);
      x.restore();
      return;
    }
    for(let dy=-r; dy<=r; dy++){
      for(let dx=-r; dx<=r; dx++){
        if(dx*dx + dy*dy > r*r) continue;
        x.drawImage(maskC, dx, dy);
      }
    }
    x.restore();
  }

  function tintMaskTo(x, W, H, color){
    x.save();
    x.globalCompositeOperation = "source-in";
    x.fillStyle = color;
    x.fillRect(0,0,W,H);
    x.restore();
  }

  function drawGlowFromMask(targetX, W, H, scale, hit){
    const blur = Math.max(0, hit.glowBlur * scale);
    if(blur <= 0) return;

    targetX.save();
    targetX.shadowBlur = blur;
    targetX.shadowColor = hit.glowColor;
    targetX.shadowOffsetX = 0;
    targetX.shadowOffsetY = 0;

    clearCtx(workX, W, H);
    workX.drawImage(maskC, 0,0);
    tintMaskTo(workX, W, H, "#ffffff");

    targetX.drawImage(workC, 0,0);
    targetX.restore();
  }

  function drawShadowFromMask(targetX, W, H, scale, hit){
    const blur = Math.max(0, hit.shadowBlur * scale);
    const ox = hit.shadowX * scale;
    const oy = hit.shadowY * scale;
    if(blur <= 0 && ox === 0 && oy === 0) return;

    targetX.save();
    targetX.shadowBlur = blur;
    targetX.shadowColor = hit.shadowColor;
    targetX.shadowOffsetX = ox;
    targetX.shadowOffsetY = oy;

    clearCtx(workX, W, H);
    workX.drawImage(maskC, 0,0);
    tintMaskTo(workX, W, H, "#ffffff");

    targetX.drawImage(workC, 0,0);
    targetX.restore();
  }

  function drawOutlineFromMask(targetX, W, H, scale, hit){
    const outlinePx = Math.max(0, hit.strokeW * scale);
    if(outlinePx <= 0) return;

    clearCtx(workX, W, H);
    expandMaskTo(workX, W, H, outlinePx);

    workX.save();
    workX.globalCompositeOperation = "destination-out";
    workX.drawImage(maskC, 0,0);
    workX.restore();

    tintMaskTo(workX, W, H, hit.stroke);
    targetX.drawImage(workC, 0,0);
  }

  function drawFillFromMask(targetX, W, H, hit){
    clearCtx(workX, W, H);
    workX.drawImage(maskC, 0,0);
    tintMaskTo(workX, W, H, hit.fill);
    targetX.drawImage(workC, 0,0);
  }

  async function renderMaster(key){
    const hit = per[key];
    setSize(masterC, MASTER_W, MASTER_H);
    setSize(maskC, MASTER_W, MASTER_H);
    setSize(workC, MASTER_W, MASTER_H);

    clearCtx(masterX, MASTER_W, MASTER_H);

    // mask do texto (centro travado)
    renderTextMask(maskX, MASTER_W, MASTER_H, MASTER_SCALE, hit);

    // ordem definida (mais “crisp”)
    drawShadowFromMask(masterX, MASTER_W, MASTER_H, MASTER_SCALE, hit);
    drawGlowFromMask(masterX, MASTER_W, MASTER_H, MASTER_SCALE, hit);
    drawOutlineFromMask(masterX, MASTER_W, MASTER_H, MASTER_SCALE, hit);
    drawFillFromMask(masterX, MASTER_W, MASTER_H, hit);

    return masterC;
  }

  async function renderPreview(){
    canvas.width = MASTER_W;
    canvas.height = MASTER_H;

    clearCtx(ctx, MASTER_W, MASTER_H);
    const master = await renderMaster(active);
    ctx.drawImage(master, 0,0);

    $("whichPill").textContent = `editando: ${active}`;
    $("fontPill").textContent = `fonte: ${getFontName(per[active].fontKey)}`;
  }

  function canvasToBlob(cnv){
    return new Promise((resolve)=>cnv.toBlob(b=>resolve(b), "image/png"));
  }

  async function renderNormalFromMaster(master){
    setSize(downC, BASE_W, BASE_H);
    downX.clearRect(0,0,BASE_W,BASE_H);

    downX.imageSmoothingEnabled = true;
    downX.imageSmoothingQuality = "high";
    downX.drawImage(master, 0,0, MASTER_W,MASTER_H, 0,0, BASE_W,BASE_H);

    return downC;
  }

  function downloadBlob(blob, filename){
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download=filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
  }

  // ==========================================================
  // 5) FONT LOADER (local /fonts)
  // ==========================================================
  const loadedFonts = new Set();
  function getFontName(fontKey){
    const item = FONT_LIBRARY[fontKey] || FONT_LIBRARY[0];
    return item?.name || "Arial";
  }

  async function ensureFontLoaded(fontKey){
    const item = FONT_LIBRARY[fontKey] || FONT_LIBRARY[0];
    if(!item || !item.file) return;

    const family = item.name;
    if(loadedFonts.has(family)) return;

    try{
      const url = `fonts/${encodeURIComponent(item.file)}`;
      const face = new FontFace(family, `url(${url})`);
      await face.load();
      document.fonts.add(face);
      loadedFonts.add(family);
      $("statusPill").textContent = "fonte ok";
    }catch(err){
      console.error(err);
      $("statusPill").textContent = "erro fonte";
      toast("Falha ao carregar fonte local");
    }
  }

  function buildFontSelect(){
    const sel = $("fontSelect");
    sel.innerHTML = "";
    FONT_LIBRARY.forEach((f, idx)=>{
      const o = document.createElement("option");
      o.value = String(idx);
      o.textContent = f.name + (f.file ? "" : " (sistema)");
      sel.appendChild(o);
    });
  }

  // ==========================================================
  // 6) UI
  // ==========================================================
  function buildTabs(){
    const root = $("tabs");
    root.innerHTML = "";
    for(const k of keys){
      const b=document.createElement("div");
      b.className="tab"+(k===active?" active":"");
      b.textContent=k;
      b.addEventListener("click", async ()=>{
        active = k;
        await ensureFontLoaded(per[active].fontKey);
        syncAllForActive();
        buildTabs();
        renderPreview();
      });
      root.appendChild(b);
    }
  }

  function syncAllForActive(){
    const hit = per[active];

    $("txt").value = hit.text;

    $("fill").value = hit.fill;
    $("stroke").value = hit.stroke;
    $("shadowColor").value = hit.shadowColor;
    $("glowColor").value = hit.glowColor;

    $("fontSelect").value = String(hit.fontKey);

    syncControl("fontSize", "s_fontSize", "n_fontSize");
    syncControl("tracking", "s_tracking", "n_tracking");
    syncControl("skewDeg", "s_skew", "n_skew");
    syncControl("strokeW", "s_strokeW", "n_strokeW");
    syncControl("shadowBlur", "s_shadowBlur", "n_shadowBlur");
    syncControl("shadowX", "s_shadowX", "n_shadowX");
    syncControl("shadowY", "s_shadowY", "n_shadowY");
    syncControl("glowBlur", "s_glowBlur", "n_glowBlur");
  }

  // binds (sliders + numbers)
  bindRangePair("fontSize", "s_fontSize", "n_fontSize");
  bindRangePair("tracking", "s_tracking", "n_tracking");
  bindRangePair("skewDeg",  "s_skew", "n_skew");
  bindRangePair("strokeW",  "s_strokeW", "n_strokeW");
  bindRangePair("shadowBlur","s_shadowBlur", "n_shadowBlur");
  bindRangePair("shadowX",  "s_shadowX", "n_shadowX");
  bindRangePair("shadowY",  "s_shadowY", "n_shadowY");
  bindRangePair("glowBlur", "s_glowBlur", "n_glowBlur");

  // outros inputs por hit
  $("txt").addEventListener("input", (e)=>{
    per[active].text = e.target.value;
    renderPreview();
  });

  $("fill").addEventListener("input", (e)=>{ per[active].fill = e.target.value; renderPreview(); });
  $("stroke").addEventListener("input", (e)=>{ per[active].stroke = e.target.value; renderPreview(); });
  $("shadowColor").addEventListener("input", (e)=>{ per[active].shadowColor = e.target.value; renderPreview(); });
  $("glowColor").addEventListener("input", (e)=>{ per[active].glowColor = e.target.value; renderPreview(); });

  $("fontSelect").addEventListener("change", async (e)=>{
    const idx = Number(e.target.value);
    per[active].fontKey = Number.isFinite(idx) ? idx : 0;
    $("statusPill").textContent = "carregando fonte…";
    await ensureFontLoaded(per[active].fontKey);
    await document.fonts.ready;
    renderPreview();
  });

  $("toggleBG").addEventListener("click", ()=>{
    shared.previewBG = !shared.previewBG;
    renderPreview();
    toast(`Fundo preview: ${shared.previewBG ? "ON" : "OFF"}`);
  });

  // export
  async function exportOne(key){
    await ensureFontLoaded(per[key].fontKey);
    await document.fonts.ready;

    const master = await renderMaster(key);
    const normal = await renderNormalFromMaster(master);

    const b1 = await canvasToBlob(normal);
    downloadBlob(b1, `${sanitizeName(key)}.png`);
    await sleep(140);

    const b2 = await canvasToBlob(master);
    downloadBlob(b2, `${sanitizeName(key)}@2x.png`);
  }

  $("downloadOne").addEventListener("click", async ()=>{
    await exportOne(active);
    toast(`Baixando ${active} + @2x…`);
    await renderPreview();
  });

  $("exportAll").addEventListener("click", async ()=>{
    for(const k of keys){
      await exportOne(k);
      await sleep(180);
    }
    toast("Exportou 12 PNGs ✅");
    await renderPreview();
  });

  $("reset").addEventListener("click", async ()=>{
    for(const k of keys) per[k] = makeDefaultsForHit(k);
    active = "300";
    buildTabs();
    buildFontSelect();
    await ensureFontLoaded(per[active].fontKey);
    syncAllForActive();
    $("statusPill").textContent = "reset";
    toast("Reset feito");
    await renderPreview();
  });

  // init
  (async function init(){
    buildTabs();
    buildFontSelect();
    await ensureFontLoaded(per[active].fontKey);
    syncAllForActive();
    await document.fonts.ready;
    await renderPreview();
    toast("Pronto ✅");
  })();
</script>
</body>
</html>
