<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>osu!mania judgement-maker</title>
  <style>
    :root{
      --bg:#0b0c0f; --fg:#e8e8e8; --muted:#9aa0a6;
      --panel:rgba(255,255,255,.04); --border:rgba(255,255,255,.10);
      --accent:#7c5cff; --r:14px; --r2:10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:radial-gradient(1200px 700px at 70% 10%, rgba(124,92,255,.20), transparent 60%),
                 radial-gradient(900px 600px at 10% 10%, rgba(0,212,255,.12), transparent 60%),
                 var(--bg);
      color:var(--fg);
    }
    header{
      padding:18px 18px 10px;
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.20);
      backdrop-filter: blur(8px);
      position:sticky; top:0; z-index:5;
    }
    header h1{margin:0; font-size:16px; letter-spacing:.2px}
    header .hint{color:var(--muted); font-size:12px}

    .wrap{
      padding:18px;
      display:grid;
      grid-template-columns: 460px 1fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns: 1fr;}
    }

    .card{
      border:1px solid var(--border);
      background:var(--panel);
      border-radius:var(--r);
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card .title{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .card .title strong{font-size:13px}
    .card .content{padding:12px}

    .tabs{
      display:flex; flex-wrap:wrap; gap:8px;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.14);
    }
    .tab{
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      padding:8px 10px;
      border-radius: var(--r2); /* menos redondo */
      font-family:var(--mono);
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{
      background:rgba(124,92,255,.30);
      border-color:rgba(124,92,255,.55);
      color:var(--fg);
    }

    .field{display:flex; flex-direction:column; gap:6px; margin-bottom:10px}
    label{font-size:12px; color:var(--muted)}
    input[type="text"], select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--fg);
      outline:none;
    }
    input[type="file"]{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px dashed var(--border);
      background:rgba(0,0,0,.18);
      color:var(--muted);
    }
    input[type="color"]{
      width:100%;
      height:40px;
      border-radius:12px;
      border:1px solid var(--border);
      background:transparent;
      padding:4px;
    }

    .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .row3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px}

    .btns{display:flex; flex-wrap:wrap; gap:10px}
    button{
      border:1px solid var(--border);
      background:rgba(124,92,255,.18);
      color:var(--fg);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
      font-size:12px;
    }
    button:hover{background:rgba(124,92,255,.28)}
    button.secondary{background:rgba(255,255,255,.06)}
    button.secondary:hover{background:rgba(255,255,255,.10)}
    button.danger{background:rgba(255,80,80,.15)}
    button.danger:hover{background:rgba(255,80,80,.22)}

    .pill{
      font-family:var(--mono);
      font-size:11px;
      padding:4px 8px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.22);
      color:var(--muted);
    }
    .divider{height:1px; background:var(--border); margin:10px 0}
    .small{font-size:12px; color:var(--muted); line-height:1.4}

    .stage{display:flex; flex-direction:column; gap:12px; padding:12px;}
    .stageTop{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .stageTop .left{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    .stageTop .right{display:flex; align-items:center; gap:8px; flex-wrap:wrap}

    .canvasWrap{
      border-radius:18px;
      border:1px solid var(--border);
      background:
        linear-gradient(45deg, rgba(255,255,255,.06) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.06) 75%, rgba(255,255,255,.06)),
        linear-gradient(45deg, rgba(255,255,255,.06) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.06) 75%, rgba(255,255,255,.06));
      background-position: 0 0, 14px 14px;
      background-size: 28px 28px;
      overflow:hidden;
      position:relative;
      padding:18px;
    }
    canvas{
      display:block;
      width:100%;
      max-width: 980px;
      height:auto;
      margin:0 auto;
      border-radius:14px;
      background:transparent;
      image-rendering:auto;
    }

    /* sliders */
    .sliderRow{
      display:flex; align-items:center; gap:10px;
      padding:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.22);
      border-radius:12px;
    }
    .sliderRow input[type="range"]{width:100%}
    .val{
      font-family:var(--mono);
      font-size:12px;
      min-width:52px;
      text-align:right;
      color:var(--fg);
      opacity:.9;
    }

    .toast{
      position:fixed; right:14px; bottom:14px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.55);
      color:var(--fg);
      font-size:12px;
      opacity:0;
      transform:translateY(8px);
      transition:.2s;
      pointer-events:none;
    }
    .toast.show{opacity:1; transform:translateY(0)}
  </style>
</head>
<body>
<header>
  <h1>judgement-maker</h1>
  <span class="hint">Export fixo: 288√ó56 e 576√ó112 (@2x). Master sempre @2x. Texto/√≠cone sempre centralizados.</span>
</header>

<div class="wrap">
  <section class="card">
    <div class="title">
      <strong>Config</strong>
      <span class="pill" id="statusPill">pronto</span>
    </div>

    <div class="tabs" id="tabs"></div>

    <div class="content">
      <div class="field">
        <label>Texto do judgement (s√≥ deste selecionado)</label>
        <input id="txt" type="text" value="300" />
      </div>

      <div class="row">
        <div class="field">
          <label>Fonte (nome)</label>
          <input id="fontName" type="text" value="Arial Black" />
        </div>
        <div class="field">
          <label>Upload de fonte (.ttf/.otf)</label>
          <input id="fontFile" type="file" accept=".ttf,.otf" />
        </div>
      </div>

      <div class="divider"></div>

      <div class="field">
        <label>Tamanho da fonte</label>
        <div class="sliderRow">
          <input id="s_fontSize" type="range" min="0" max="100" value="55" />
          <div class="val" id="v_fontSize"></div>
        </div>
      </div>

      <div class="row">
        <div class="field">
          <label>Tracking</label>
          <div class="sliderRow">
            <input id="s_tracking" type="range" min="0" max="100" value="50" />
            <div class="val" id="v_tracking"></div>
          </div>
        </div>
        <div class="field">
          <label>Inclina√ß√£o</label>
          <div class="sliderRow">
            <input id="s_skew" type="range" min="0" max="100" value="50" />
            <div class="val" id="v_skew"></div>
          </div>
        </div>
      </div>

      <div class="row3">
        <div class="field">
          <label>Cor do texto</label>
          <input id="fill" type="color" value="#ffffff" />
        </div>
        <div class="field">
          <label>Outline</label>
          <div class="sliderRow">
            <input id="s_strokeW" type="range" min="0" max="100" value="35" />
            <div class="val" id="v_strokeW"></div>
          </div>
        </div>
        <div class="field">
          <label>Cor do outline</label>
          <input id="stroke" type="color" value="#000000" />
        </div>
      </div>

      <div class="row3">
        <div class="field">
          <label>Sombra blur</label>
          <div class="sliderRow">
            <input id="s_shadowBlur" type="range" min="0" max="100" value="0" />
            <div class="val" id="v_shadowBlur"></div>
          </div>
        </div>
        <div class="field">
          <label>Sombra X</label>
          <div class="sliderRow">
            <input id="s_shadowX" type="range" min="0" max="100" value="50" />
            <div class="val" id="v_shadowX"></div>
          </div>
        </div>
        <div class="field">
          <label>Sombra Y</label>
          <div class="sliderRow">
            <input id="s_shadowY" type="range" min="0" max="100" value="50" />
            <div class="val" id="v_shadowY"></div>
          </div>
        </div>
      </div>

      <div class="row3">
        <div class="field">
          <label>Cor da sombra</label>
          <input id="shadowColor" type="color" value="#000000" />
        </div>
        <div class="field">
          <label>Glow blur</label>
          <div class="sliderRow">
            <input id="s_glowBlur" type="range" min="0" max="100" value="35" />
            <div class="val" id="v_glowBlur"></div>
          </div>
        </div>
        <div class="field">
          <label>Cor do glow</label>
          <input id="glowColor" type="color" value="#7c5cff" />
        </div>
      </div>

      <div class="divider"></div>

      <div class="field">
        <label>√çcone (√∫nico estilo)</label>
        <select id="iconPick">
          <option value="none">Nenhum</option>
          <option value="pill">P√≠lula</option>
          <option value="dot">Bolinha pequena</option>
        </select>
      </div>

      <div class="row3">
        <div class="field">
          <label>Cor do √≠cone</label>
          <input id="iconColor" type="color" value="#ffffff" />
        </div>
        <div class="field">
          <label>√çcone escala</label>
          <div class="sliderRow">
            <input id="s_iconScale" type="range" min="0" max="100" value="50" />
            <div class="val" id="v_iconScale"></div>
          </div>
        </div>
        <div class="field">
          <label>√çcone atr√°s do texto?</label>
          <select id="iconBehind">
            <option value="yes" selected>Sim</option>
            <option value="no">N√£o</option>
          </select>
        </div>
      </div>

      <div class="divider"></div>

      <div class="btns">
        <button id="downloadOne" type="button">Baixar (selecionado + @2x)</button>
        <button id="exportAll" type="button">Exportar 12 PNGs</button>
        <button id="reset" class="secondary" type="button">Reset</button>
      </div>

      <p class="small">
        Master sempre em <b>576√ó112</b>. O arquivo <b>288√ó56</b> √© um downscale do master.<br/>
        Centraliza√ß√£o travada: texto e √≠cone sempre no centro.
      </p>
    </div>
  </section>

  <section class="card">
    <div class="title">
      <strong>Preview</strong>
      <div class="right">
        <button id="toggleBG" class="secondary" type="button">Fundo preview</button>
      </div>
    </div>

    <div class="stage">
      <div class="stageTop">
        <div class="left">
          <span class="pill" id="dimPill">576√ó112 (preview)</span>
          <span class="pill" id="fontPill">fonte: Arial Black</span>
          <span class="pill" id="whichPill">editando: 300</span>
        </div>
      </div>

      <div class="canvasWrap">
        <canvas id="c"></canvas>
      </div>

      <p class="small">Export sai com fundo transparente. Xadrez √© s√≥ preview.</p>
    </div>
  </section>
</div>

<div class="toast" id="toast"></div>

<script>
  // ================= helpers =================
  const $ = (id)=>document.getElementById(id);
  const toast = (msg)=>{
    const t=$("toast");
    t.textContent=msg; t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm=setTimeout(()=>t.classList.remove("show"),1600);
  };
  const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
  const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
  const sanitizeName=(s)=> (s||"judgement").toString().trim()
    .replace(/[\\/:*?"<>|]+/g,"").replace(/\s+/g,"_").slice(0,80) || "judgement";

  // ================= fixed sizes =================
  const BASE_W = 288, BASE_H = 56;
  const MASTER_SCALE = 2;
  const MASTER_W = BASE_W * MASTER_SCALE;
  const MASTER_H = BASE_H * MASTER_SCALE;

  // ================= state =================
  const keys = ["0","50","100","200","300","300g"];
  const per = {};
  for(const k of keys){
    per[k] = {
      text: k,
      icon: "none",         // none | pill | dot
      iconColor: "#ffffff",
      iconScale01: 0.50,    // 0..1
      iconBehind: true
    };
  }
  let active = "300";

  // ================= sliders mapping (0..100) =================
  // Cada slider √© 0..100, mas internamente mapeamos pra um range √∫til.
  // Isso atende seu pedido: "barra de drag 0 a 100 em todas as op√ß√µes".
  const shared = {
    fontName: "Arial Black",
    previewBG: false,

    // internal numeric values
    fontSize: 34,       // base units (288x56)
    tracking: 0,        // px
    skewDeg: 0,         // degrees

    fill: "#ffffff",
    strokeW: 4,         // px
    stroke: "#000000",

    shadowBlur: 0,      // px
    shadowX: 0,         // px
    shadowY: 0,         // px
    shadowColor: "#000000",

    glowBlur: 10,       // px
    glowColor: "#7c5cff",
  };

  // Map functions (slider 0..100 -> value)
  const map = {
    fontSize: (s)=> 18 + (s/100) * 52,           // 18..70
    tracking: (s)=> ((s-50)/50) * 8,             // -8..+8
    skewDeg:  (s)=> ((s-50)/50) * 14,            // -14..+14

    strokeW:  (s)=> (s/100) * 10,                // 0..10
    glowBlur: (s)=> (s/100) * 22,                // 0..22

    shadowBlur:(s)=> (s/100) * 18,               // 0..18
    shadowX:   (s)=> ((s-50)/50) * 10,           // -10..+10
    shadowY:   (s)=> ((s-50)/50) * 10,           // -10..+10

    iconScale01:(s)=> (s/100),                   // 0..1
  };

  // ================= canvas setup =================
  const canvas = $("c");
  const ctx = canvas.getContext("2d");

  // offscreen: mask + work buffers + export buffers
  const maskC = document.createElement("canvas");
  const maskX = maskC.getContext("2d");

  const workC = document.createElement("canvas");
  const workX = workC.getContext("2d");

  const masterC = document.createElement("canvas");
  const masterX = masterC.getContext("2d");

  const downC = document.createElement("canvas");
  const downX = downC.getContext("2d");

  function setSize(cnv, w, h){
    cnv.width = w; cnv.height = h;
  }

  function clearCtx(x, w, h){
    x.clearRect(0,0,w,h);
    if(shared.previewBG){
      x.save();
      x.fillStyle = "rgba(0,0,0,.35)";
      x.fillRect(0,0,w,h);
      x.restore();
    }
  }

  // ================= drawing primitives =================
  function drawIconShape(x, W, H, scale, icon, color, scale01){
    if(icon === "none") return;

    const cx = W/2;
    const cy = H/2;

    x.save();
    x.fillStyle = color;

    if(icon === "pill"){
      // pill horizontal: size tuned for judgement area
      const baseW = 84 * scale;
      const baseH = 22 * scale;
      const w = baseW * (0.35 + 1.25*scale01);  // never too tiny
      const h = baseH * (0.35 + 1.25*scale01);
      const rx = h/2;

      const px = cx - w/2;
      const py = cy - h/2;

      // rounded rect
      x.beginPath();
      x.moveTo(px+rx, py);
      x.lineTo(px+w-rx, py);
      x.quadraticCurveTo(px+w, py, px+w, py+rx);
      x.lineTo(px+w, py+h-rx);
      x.quadraticCurveTo(px+w, py+h, px+w-rx, py+h);
      x.lineTo(px+rx, py+h);
      x.quadraticCurveTo(px, py+h, px, py+h-rx);
      x.lineTo(px, py+rx);
      x.quadraticCurveTo(px, py, px+rx, py);
      x.closePath();
      x.fill();
    }else if(icon === "dot"){
      // small dot
      const r = (6 * scale) * (0.35 + 1.6*scale01);
      x.beginPath();
      x.arc(cx, cy, r, 0, Math.PI*2);
      x.fill();
    }

    x.restore();
  }

  function setupTextCtx(x, scale){
    x.font = `${shared.fontSize*scale}px "${shared.fontName}"`;
    x.textAlign = "center";
    x.textBaseline = "alphabetic";
  }

  // Render text mask (white) centered, snapped to integer pixels (reduz blur)
  function renderTextMask(x, W, H, scale, text){
    clearCtx(x, W, H);
    x.save();
    setupTextCtx(x, scale);
    x.fillStyle = "#ffffff";

    const m = x.measureText(text);
    const ascent  = (m.actualBoundingBoxAscent ?? m.fontBoundingBoxAscent ?? (shared.fontSize*0.8));
    const descent = (m.actualBoundingBoxDescent ?? m.fontBoundingBoxDescent ?? (shared.fontSize*0.2));

    const baselineToMiddle = (ascent - descent)/2;

    // centraliza√ß√£o travada
    const cx = Math.round(W/2); // snapping
    const y0 = Math.round(H/2 + baselineToMiddle);

    // tracking manual
    const tracking = shared.tracking * scale;

    if(!tracking){
      x.fillText(text, cx, y0);
    }else{
      const chars=[...text];
      const widths=chars.map(ch=>x.measureText(ch).width);
      const total=widths.reduce((a,b)=>a+b,0)+tracking*(chars.length-1);
      let startX = cx - total/2;
      for(let i=0;i<chars.length;i++){
        const px = startX + widths[i]/2;
        x.fillText(chars[i], px, y0);
        startX += widths[i] + tracking;
      }
    }

    x.restore();
  }

  // Expand mask by radius using multi-offset stamping (outline backbone)
  function expandMaskTo(x, W, H, radiusPx){
    // x already cleared by caller
    x.save();
    x.globalCompositeOperation = "source-over";
    x.imageSmoothingEnabled = true;

    const r = Math.max(0, Math.round(radiusPx));
    if(r === 0){
      x.drawImage(maskC, 0,0);
      x.restore();
      return;
    }

    // stamp in a disk-ish pattern
    for(let dy=-r; dy<=r; dy++){
      for(let dx=-r; dx<=r; dx++){
        if(dx*dx + dy*dy > r*r) continue;
        x.drawImage(maskC, dx, dy);
      }
    }
    x.restore();
  }

  function tintMaskTo(x, W, H, color){
    x.save();
    x.globalCompositeOperation = "source-in";
    x.fillStyle = color;
    x.fillRect(0,0,W,H);
    x.restore();
  }

  function drawGlowFromMask(targetX, W, H, scale){
    const blur = Math.max(0, shared.glowBlur * scale);
    if(blur <= 0) return;

    // draw tinted mask with shadowBlur = glow
    targetX.save();
    targetX.shadowBlur = blur;
    targetX.shadowColor = shared.glowColor;
    targetX.shadowOffsetX = 0;
    targetX.shadowOffsetY = 0;
    targetX.globalAlpha = 1;

    // draw a solid rect clipped by mask, so shadow uses mask silhouette
    // (we use workC as mask->color)
    clearCtx(workX, W, H);
    workX.drawImage(maskC, 0,0);
    tintMaskTo(workX, W, H, "#ffffff");

    // drawing the mask onto target triggers the shadow glow
    targetX.drawImage(workC, 0,0);
    targetX.restore();
  }

  function drawShadowFromMask(targetX, W, H, scale){
    const blur = Math.max(0, shared.shadowBlur * scale);
    const ox = shared.shadowX * scale;
    const oy = shared.shadowY * scale;
    if(blur <= 0 && ox === 0 && oy === 0) return;

    targetX.save();
    targetX.shadowBlur = blur;
    targetX.shadowColor = shared.shadowColor;
    targetX.shadowOffsetX = ox;
    targetX.shadowOffsetY = oy;

    clearCtx(workX, W, H);
    workX.drawImage(maskC, 0,0);
    tintMaskTo(workX, W, H, "#ffffff");

    targetX.drawImage(workC, 0,0);
    targetX.restore();
  }

  function drawOutlineFromMask(targetX, W, H, scale){
    const outlinePx = Math.max(0, shared.strokeW * scale);
    if(outlinePx <= 0) return;

    // expanded mask into workC
    clearCtx(workX, W, H);
    expandMaskTo(workX, W, H, outlinePx);

    // subtract original mask -> keep only border
    workX.save();
    workX.globalCompositeOperation = "destination-out";
    workX.drawImage(maskC, 0,0);
    workX.restore();

    // tint border
    tintMaskTo(workX, W, H, shared.stroke);

    targetX.drawImage(workC, 0,0);
  }

  function drawFillFromMask(targetX, W, H){
    clearCtx(workX, W, H);
    workX.drawImage(maskC, 0,0);
    tintMaskTo(workX, W, H, shared.fill);
    targetX.drawImage(workC, 0,0);
  }

  async function renderMaster(key){
    setSize(masterC, MASTER_W, MASTER_H);
    clearCtx(masterX, MASTER_W, MASTER_H);

    const jd = per[key];
    const scale = MASTER_SCALE;

    // icon behind
    if(jd.iconBehind){
      drawIconShape(masterX, MASTER_W, MASTER_H, scale, jd.icon, jd.iconColor, jd.iconScale01);
    }

    // text pipeline
    setSize(maskC, MASTER_W, MASTER_H);
    setSize(workC, MASTER_W, MASTER_H);
    renderTextMask(maskX, MASTER_W, MASTER_H, scale, jd.text);

    // order: shadow -> glow -> outline -> fill (fica mais definido)
    drawShadowFromMask(masterX, MASTER_W, MASTER_H, scale);
    drawGlowFromMask(masterX, MASTER_W, MASTER_H, scale);
    drawOutlineFromMask(masterX, MASTER_W, MASTER_H, scale);
    drawFillFromMask(masterX, MASTER_W, MASTER_H);

    // icon front
    if(!jd.iconBehind){
      drawIconShape(masterX, MASTER_W, MASTER_H, scale, jd.icon, jd.iconColor, jd.iconScale01);
    }

    return masterC;
  }

  async function renderPreview(){
    canvas.width = MASTER_W;
    canvas.height = MASTER_H;
    clearCtx(ctx, MASTER_W, MASTER_H);

    const master = await renderMaster(active);
    ctx.drawImage(master, 0,0);

    $("fontPill").textContent = `fonte: ${shared.fontName}`;
    $("whichPill").textContent = `editando: ${active}`;
  }

  function canvasToBlob(cnv){
    return new Promise((resolve)=>cnv.toBlob(b=>resolve(b), "image/png"));
  }

  async function renderNormalFromMaster(master){
    setSize(downC, BASE_W, BASE_H);
    downX.clearRect(0,0,BASE_W,BASE_H);

    // downscale com qualidade alta (sem mudar pixels)
    downX.imageSmoothingEnabled = true;
    downX.imageSmoothingQuality = "high";
    downX.drawImage(master, 0,0, MASTER_W,MASTER_H, 0,0, BASE_W,BASE_H);

    return downC;
  }

  function downloadBlob(blob, filename){
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download=filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
  }

  // ================= UI build =================
  function buildTabs(){
    const root = $("tabs");
    root.innerHTML = "";
    for(const k of keys){
      const b=document.createElement("div");
      b.className="tab"+(k===active?" active":"");
      b.textContent=k;
      b.addEventListener("click", ()=>{
        active = k;
        syncUIFromActive();
        buildTabs();
        renderPreview();
      });
      root.appendChild(b);
    }
  }

  function syncUIFromActive(){
    const jd = per[active];
    $("txt").value = jd.text;
    $("iconPick").value = jd.icon;
    $("iconColor").value = jd.iconColor;
    $("iconBehind").value = jd.iconBehind ? "yes" : "no";

    // slider icon
    $("s_iconScale").value = Math.round(jd.iconScale01*100);
    updateSliderLabels();
  }

  function updateSliderLabels(){
    $("v_fontSize").textContent = `${shared.fontSize.toFixed(0)}px`;
    $("v_tracking").textContent = `${shared.tracking.toFixed(1)}`;
    $("v_skew").textContent = `${shared.skewDeg.toFixed(1)}¬∞`;
    $("v_strokeW").textContent = `${shared.strokeW.toFixed(1)}`;
    $("v_glowBlur").textContent = `${shared.glowBlur.toFixed(1)}`;
    $("v_shadowBlur").textContent = `${shared.shadowBlur.toFixed(1)}`;
    $("v_shadowX").textContent = `${shared.shadowX.toFixed(1)}`;
    $("v_shadowY").textContent = `${shared.shadowY.toFixed(1)}`;
    $("v_iconScale").textContent = `${(per[active].iconScale01*100).toFixed(0)}%`;
  }

  // ================= slider bindings (0..100 everywhere) =================
  function bindSlider(id, apply){
    const el=$(id);
    const run=()=>{
      apply(Number(el.value));
      updateSliderLabels();
      renderPreview();
    };
    el.addEventListener("input", run);
    el.addEventListener("change", run);
  }

  bindSlider("s_fontSize", (s)=> shared.fontSize = map.fontSize(s));
  bindSlider("s_tracking", (s)=> shared.tracking = map.tracking(s));
  bindSlider("s_skew",    (s)=> shared.skewDeg  = map.skewDeg(s));
  bindSlider("s_strokeW", (s)=> shared.strokeW  = map.strokeW(s));
  bindSlider("s_glowBlur",(s)=> shared.glowBlur = map.glowBlur(s));
  bindSlider("s_shadowBlur",(s)=> shared.shadowBlur = map.shadowBlur(s));
  bindSlider("s_shadowX", (s)=> shared.shadowX = map.shadowX(s));
  bindSlider("s_shadowY", (s)=> shared.shadowY = map.shadowY(s));

  bindSlider("s_iconScale", (s)=> per[active].iconScale01 = map.iconScale01(s));

  // ================= other bindings =================
  $("txt").addEventListener("input", (e)=>{
    per[active].text = e.target.value;
    renderPreview();
  });

  $("fontName").addEventListener("input", (e)=>{
    shared.fontName = e.target.value || "Arial Black";
    renderPreview();
  });

  $("fill").addEventListener("input", (e)=>{ shared.fill = e.target.value; renderPreview(); });
  $("stroke").addEventListener("input", (e)=>{ shared.stroke = e.target.value; renderPreview(); });
  $("shadowColor").addEventListener("input", (e)=>{ shared.shadowColor = e.target.value; renderPreview(); });
  $("glowColor").addEventListener("input", (e)=>{ shared.glowColor = e.target.value; renderPreview(); });

  $("iconPick").addEventListener("change", (e)=>{
    per[active].icon = e.target.value;
    renderPreview();
  });
  $("iconColor").addEventListener("input", (e)=>{
    per[active].iconColor = e.target.value;
    renderPreview();
  });
  $("iconBehind").addEventListener("change", (e)=>{
    per[active].iconBehind = (e.target.value === "yes");
    renderPreview();
  });

  $("toggleBG").addEventListener("click", ()=>{
    shared.previewBG = !shared.previewBG;
    renderPreview();
    toast(`Fundo preview: ${shared.previewBG ? "ON" : "OFF"}`);
  });

  // ================= font upload =================
  $("fontFile").addEventListener("change", async (e)=>{
    const file = e.target.files?.[0];
    if(!file) return;
    try{
      const buf = await file.arrayBuffer();
      const fname = file.name.replace(/\.(ttf|otf)$/i,"");
      const face = new FontFace(fname, buf);
      $("statusPill").textContent = "carregando fonte‚Ä¶";
      await face.load();
      document.fonts.add(face);
      shared.fontName = fname;
      $("fontName").value = fname;
      $("statusPill").textContent = "fonte ok";
      toast("Fonte carregada ‚úÖ");
      await document.fonts.ready;
      renderPreview();
    }catch(err){
      console.error(err);
      $("statusPill").textContent = "erro fonte";
      toast("Falha ao carregar fonte üòµ");
    }
  });

  // ================= export =================
  async function exportOne(key){
    const master = await renderMaster(key);
    const normal = await renderNormalFromMaster(master);

    const b1 = await canvasToBlob(normal);
    downloadBlob(b1, `${sanitizeName(key)}.png`);
    await sleep(140);

    const b2 = await canvasToBlob(master);
    downloadBlob(b2, `${sanitizeName(key)}@2x.png`);
  }

  $("downloadOne").addEventListener("click", async ()=>{
    await exportOne(active);
    toast(`Baixando ${active} + @2x‚Ä¶`);
    await renderPreview();
  });

  $("exportAll").addEventListener("click", async ()=>{
    for(const k of keys){
      await exportOne(k);
      await sleep(180);
    }
    toast("Exportou 12 PNGs ‚úÖ");
    await renderPreview();
  });

  $("reset").addEventListener("click", async ()=>{
    // reset sliders (0..100) to defaults
    $("s_fontSize").value = 55;   // ~34px
    $("s_tracking").value = 50;   // 0
    $("s_skew").value = 50;       // 0
    $("s_strokeW").value = 35;    // ~3.5
    $("s_glowBlur").value = 35;   // ~7.7
    $("s_shadowBlur").value = 0;
    $("s_shadowX").value = 50;
    $("s_shadowY").value = 50;

    shared.fontName = "Arial Black";
    $("fontName").value = shared.fontName;

    shared.fill = "#ffffff"; $("fill").value = shared.fill;
    shared.stroke = "#000000"; $("stroke").value = shared.stroke;
    shared.shadowColor = "#000000"; $("shadowColor").value = shared.shadowColor;
    shared.glowColor = "#7c5cff"; $("glowColor").value = shared.glowColor;

    // apply mappings
    shared.fontSize = map.fontSize(Number($("s_fontSize").value));
    shared.tracking = map.tracking(Number($("s_tracking").value));
    shared.skewDeg = map.skewDeg(Number($("s_skew").value));
    shared.strokeW = map.strokeW(Number($("s_strokeW").value));
    shared.glowBlur = map.glowBlur(Number($("s_glowBlur").value));
    shared.shadowBlur = map.shadowBlur(Number($("s_shadowBlur").value));
    shared.shadowX = map.shadowX(Number($("s_shadowX").value));
    shared.shadowY = map.shadowY(Number($("s_shadowY").value));

    for(const k of keys){
      per[k].text = k;
      per[k].icon = "none";
      per[k].iconColor = "#ffffff";
      per[k].iconScale01 = 0.50;
      per[k].iconBehind = true;
    }

    active = "300";
    buildTabs();
    syncUIFromActive();
    updateSliderLabels();
    $("statusPill").textContent = "reset";
    toast("Reset feito");
    await renderPreview();
  });

  // ================= init =================
  (async function init(){
    // initial apply from slider defaults
    shared.fontSize = map.fontSize(Number($("s_fontSize").value));
    shared.tracking = map.tracking(Number($("s_tracking").value));
    shared.skewDeg = map.skewDeg(Number($("s_skew").value));
    shared.strokeW = map.strokeW(Number($("s_strokeW").value));
    shared.glowBlur = map.glowBlur(Number($("s_glowBlur").value));
    shared.shadowBlur = map.shadowBlur(Number($("s_shadowBlur").value));
    shared.shadowX = map.shadowX(Number($("s_shadowX").value));
    shared.shadowY = map.shadowY(Number($("s_shadowY").value));

    buildTabs();
    syncUIFromActive();
    updateSliderLabels();
    await document.fonts.ready;
    await renderPreview();
    toast("Pronto ‚úÖ");
  })();
</script>
</body>
</html>
